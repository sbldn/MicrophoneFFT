/* autogenerated by Processing revision 1293 on 2024-05-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class MicrophoneFFT extends PApplet {



FFT fft;
AudioIn in;
int bands = 512;
float[] spectrum = new float[bands];

float counter;

public void setup() {
  /* size commented out by preprocessor */;
  background(0xFF202020);
  fft = new FFT(this, bands);
  in = new AudioIn(this, 1);
  in.start();
  fft.input(in);
  counter=0;
}

public void draw() { 
  background(0);
  noStroke();
  fill(0);
  rect(0, 0, width, height);
  stroke(255);
    
  fill(255);
  stroke(255);
  translate(width/2, height/2); // Centrar el origen en el centro de la pantalla
  
  fft.analyze(spectrum);
  
  for(int i = 0; i < bands; i=i+3){
    float angle = map(i, 0, bands, 0, TWO_PI); // Mapear el índice del espectro a un ángulo entre 0 y 2*PI
    float radius = map(spectrum[i], 0, 0.1f, 0, 256); // Mapear la amplitud del espectro al radio del punto
    
    
    
    //angle=angle+counter;
    if(angle>360){
      angle=angle-360;
    }

    //cartesiano a polares
    float x = radius * cos(angle); 
    float y = radius * sin(angle);
    
    // Dibujar el punto
    stroke(255);
    strokeWeight(2);
    // float[] cp=car2pol(radius,angle);
    //line(0,0,cp[0], cp[1]);
    drawPizza(radius,angle,1.5f*PI/180);


    



    // //Circunferencia
    stroke(255);
    float rad2=200+sin(counter/3)*random(1,2);
    
    float x2 = rad2 * cos(angle); // Convertir de coordenadas polares a cartesianas
    float y2 = rad2 * sin(angle); 
    //line(0,0,x2+x, y2+y);
    point(x2+x,y2+y);
    counter++;
     
  } 
  
  // for(int i = 0; i < 360; i++){

  //   float radius = 100;
  //   float x = radius * cos(i); // Convertir de coordenadas polares a cartesianas
  //   float y = radius * sin(i);
  //   // Dibujar el punto
   
  //   point(x,y);
  // } 

 
}


public float[] car2pol(float radius,float angle){
    float[] car=new float[2];
    car[0]=radius * cos(angle); 
    car[1]=radius * sin(angle);
    return car;
}

public void drawPizza(float radius, float angle, float distance){
    // float[] line1=car2pol(radius,angle-(distance));
    // line(0,0,line1[0], line1[1]);
    // float[] line2=car2pol(radius,angle+(distance));
    // line(0,0,line2[0], line2[1]);

    //arc(0,0,radius*2,radius*2, angle-2*(distance), angle+(distance), PIE);
    noStroke();
    
    for (int r = PApplet.parseInt(radius); r > 0; --r) {


    fill(255-r,50);

    arc(0,0,r*2,r*2, angle-2*(distance), angle+(distance), PIE);

    
}


    
}


  public void settings() { size(512, 512); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "MicrophoneFFT" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
